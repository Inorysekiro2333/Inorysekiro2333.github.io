[{"content":" Day1 无重复字符的最长子串 https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/\n解法：滑动窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); // 因为只有英文字母、数字、符号和空格组成 // 所以创建一个长度为128（askii码）的数组用来记录字符出现的次数 int[] cnt = new int[128]; int ans = 0; int l = 0; char[] charS = s.toCharArray(); // 固定左l，遍历右r for(int r = 0; r \u0026lt; n; r++) { char c = charS[r]; cnt[c]++; // r往后遍历，窗口内有字符重复时，左边l收缩窗口 while(cnt[c] \u0026gt; 1) { cnt[charS[l]]--; l++; } // 更新ans为窗口长度 ans = Math.max(ans, r - l + 1); } return ans; } } LRU缓存机制 https://leetcode.cn/problems/lru-cache/description/\n思路：使用带头尾指针的双向链表实现，使用hashMap作为缓存\nput元素时两种情况\nput的元素不在链表中，直接链表头插（addToHead），判断容量是否超过上限，如果超过了，就移除(remove)掉最后一个节点\nput的元素在链表中，从缓存中找到该节点，移动到头部（moveToHead）\nget获取元素\n如果get的元素不在缓存中，返回 -1\nget的元素在缓存中，返回节点的value，同时更新缓存（moveToHead）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class LRUCache { class Node { int key; int value; Node next; Node prev; } private final int capacity; // LRU缓存容量 private Node head, tail; // 头尾节点 private final Map\u0026lt;Integer, Node\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); // Map缓存 // 初始化 public LRUCache(int capacity) { this.capacity = capacity; head = new Node(); tail = new Node(); head.next = tail; tail.prev = head; } // put方法 public void put (int key, int value) { Node node = cache.get(key); if (node == null) { Node newNode = new Node(); newNode.key = key; newNode.value = value; cache.put(key, newNode); addToHead(newNode); if (cache.size() \u0026gt; capacity) { Node oldNode = popTail(); cache.remove(oldNode); } } else { node.value = value; moveToHead(node); } } // get方法 public int get(int key) { Node node = cache.get(key); if (node == null) return -1; moveToHead(node); return node.value; } // 辅助方法 private void moveToHead(Node node) { remove(node); addToHead(node); } private void remove(Node node) { node.prev.next = node.next; node.next.prev = node.prev; } private void addToHead(Node node) { node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; } private Node popTail() { Node res = tail.prev; remove(res); return res; } } 反转链表easy 思路：原地反转，使用3个指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode reverseList(ListNode head) { ListNode cur = head; ListNode pre = null; while (cur != null) { ListNode nxt = cur.next; cur.next = pre; pre = cur; cur = nxt; } return pre; } } 数组中的第K个最大元素 https://leetcode.cn/problems/kth-largest-element-in-an-array/description/\n思路：\n快速排序的思想，区域划分，将大于、等于、小于基准的数划分到三个数组中，之后在大于和小于的数组中递归划分，等于的直接返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public int findKthLargest(int[] nums, int k) { List\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { numList.add(num); } return quickSelect(numList, k); } public int quickSelect(List\u0026lt;Integer\u0026gt; nums, int k) { // 随机选择基准数 Random rand = new Random(); int n = nums.size(); int randNum = rand.nextInt(n); int pivot = nums.get(randNum); // 将大于、小于、等于pivot的元素分别划分到big、small、equal中 List\u0026lt;Integer\u0026gt; big = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; small = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; equal = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { if (num \u0026gt; pivot) { big.add(num); } else if (num \u0026lt; pivot) { small.add(num); } else { equal.add(num); } } // 第k大的元素在big中，递归划分 if (k \u0026lt;= big.size()) { return quickSelect(big, k); } // 第k大的元素在small中，递归划分 if (nums.size() - small.size() \u0026lt; k) { return quickSelect(small, k - nums.size() + small.size()); } // 第k大的元素在equal中，直接返回pivot return pivot; } } 解释：\nbig + equal = nums.size - small；\n如果big + equal的元素个数小于 k ，说明第k大的元素不在big和equal中，只能在small中；\n因为big和equal中的元素都比small中的大，所以在small中需要找第 k - (big + equeal的数量) 大的元素\nk个一组反转链表hard https://leetcode.cn/problems/reverse-nodes-in-k-group/description/\n思路：\n1.链表分区为已翻转部分+待翻转部分+未翻转部分\n2.每次翻转前，要确定翻转链表的范围，这个必须通过k次循环来确定\n3.需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来\n4.初始需要两个变量pre和end，pre代表待翻转链表的前驱，end代表待翻转链表的末尾\n5.经过k次循环，end 到达末尾，记录待翻转链表的后继next = end.next\n6.翻转链表，然后将三部分链表连接起来，然后重置pre和end指针，然后进入下一次循环\n7.特殊情况，当翻转部分长度不足k时，在定位end完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可\n8.时间复杂度为 O(n *K) 最好的情况为 O(n）最差的情况未 O(n²)\n9.空间复杂度为O(1）除了几个必须的节点指针外，我们并没有占用其他空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while (end.next != null) { for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; end != null; i++) end = end.next; if (end == null) break; ListNode start = pre.next; ListNode next = end.next; end.next = null; pre.next = reverse(start); start.next = next; pre = start; end = pre; } return dummy.next; } private ListNode reverse(ListNode head) { ListNode pre = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = pre; pre = curr; curr = next; } return pre; } Day2 三数之和 https://leetcode.cn/problems/3sum/description/\n思路：\n先排好序，最外层循环为 i 固定为左起第一个从后遍历（从小到大），内层循环双指针j、k，j为i后一个开始往后遍历（从小到大），k从最右边往左边遍历（从大到小）\n外层去重的点：if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i - 1] == nums[i]) continue;\n两个外层循环的优化点：\n如果i + (i+1) + (i+2) \u0026gt; 0 （最小的三个数已经大于0了）直接break掉，不进循环\n如果i + (n - 1) + (n - 2) \u0026lt; 0 （当前的i和最大的两个数都还小于0，说明当前的i太小） continue直接遍历下一个i\n内层循环：\n如果i + j + k \u0026gt; 0了，说明k大了，k\u0026ndash;\n如果i + j + k \u0026lt; 0了，说明j小了，j++\n等于0的情况下，去重 j、k ： nums[j] == nums[j - 1] ,j++; nums[k] == nums[k + 1], k\u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { // 转化为两数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i \u0026lt; n - 2; i++) { int x = nums[i]; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i - 1] == x) continue; // 去重i // 2个优化 if (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; if (x + nums[n - 1] + nums[n - 2] \u0026lt; 0) continue; int j = i + 1; int k = n - 1; while (j \u0026lt; k) { int s = x + nums[j] + nums[k]; if (s \u0026gt; 0) k--; else if (s \u0026lt; 0) j++; else { // 去重j k ans.add(List.of(x, nums[j], nums[k])); for (j++;j \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j - 1]; j++); for (k--;j \u0026lt; k \u0026amp;\u0026amp; nums[k] == nums[k + 1]; k--); } } } return ans; } } 相交链表 https://leetcode.cn/problems/intersection-of-two-linked-lists/description/\n思路：独属于理科生的情话：“走过你的来时路，只为与你相遇”\n设「第一个公共节点」为 node，「链表headA 」的节点数量为 a，「链表headB」的节点数量为b，「两链表的公共尾部」的节点数量为 c，则有：\n头节点 headA 到 node 前，共有 a－c 个节点;\n头节点 headB 到 node 前，共有 b－c 个节点;\n考虑构建两个节点指针A，B分别指向两链表头节点headA，headB，做如下操作:\n指针A 先遍历完链表headA，再开始遍历链表headB，当走到node时，共走步数为: a+ (b - c)\n指针B先遍历完链表headB，再开始遍历链表headA，当走到node时，共走步数为: b+ (a -c)\n如下式所示，此时指针A，B重合，并有两种情况:\na + (b -c) = b+ (a - c)\n若两链表有公共尾部（即 c \u0026gt; 0）：指针A，B同时指向「第一个公共节点」node。\n若两链表无公共尾部（即 c = 0）：指针A，B同时指向 null。\n因此返回A即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = new ListNode(-1, headA); ListNode pB = new ListNode(-1, headB); while(pA != pB) { pA = pA != null ? pA.next : headB; pB = pB != null ? pB.next : headA; } return pA; } } 合并区间 https://leetcode.cn/problems/merge-intervals/description/\n思路：\n先按照单个区间的第一个元素排序：Arrays.sort(intervals, (p, q) -\u0026gt; p[0] - q[0])\n遍历二维数组，对于每个拿到的元素（一维数组 int[ ] p）,如果当前遍历区间的左端点start_i \u0026lt;= 结果集合中最后一个元素的右端点end_i-1，说明是可以合并的。合并之后的右端点取当前遍历区间和结果集合最后一个元素中的大者。\nif (p[0] \u0026lt;= ans.get(m - 1)[1])\nans.get(m-1)[1] = Math.max(p[1], ans.get(m-1)[1])\n不能合并的单独加入结果集合中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (p, q) -\u0026gt; p[0] - q[0]); // 先按照单个区间的第一个元素排序 List\u0026lt;int[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int[] p : intervals) { int m = ans.size(); // 注意边界条件 // 如果当前遍历区间左端点 \u0026lt;= 列表中最后一个元素的右端点，说明是可以合并的 if (m \u0026gt; 0 \u0026amp;\u0026amp; p[0] \u0026lt;= ans.get(m - 1)[1]) { // 合并之后的右端点取两者之间的大的 ans.get(m - 1)[1] = Math.max(p[1], ans.get(m - 1)[1]); } else { ans.add(p); } } return ans.toArray(new int[ans.size()][]); } } 字符串相加 https://leetcode.cn/problems/add-strings/description/\n思路：\n设定 i, j 两个指针分别指向num1和num2的尾部，模拟人工加法\n计算进位：计算carry = tmp / 10，代表当前位相加是否产生进位；\n添加当前位：计算tmp = n1 + n2 + carry，并将当前位tmp % 10添加至res头部；\n当指针 i, j 走过数字首部后，给n1, n2赋值0，相当于给num1, num2中长度较短的数字前面填0，方便后面计算\n当遍历完num1, num2后跳出循环，并根据carry的值决定是否在头部添加进位1，最终返回res\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String addStrings(String num1, String num2) { StringBuilder res = new StringBuilder(\u0026#34;\u0026#34;); int i = num1.length() - 1, j = num2.length() - 1, carry = 0; while (i \u0026gt;= 0 || j \u0026gt;= 0) { int n1 = i \u0026gt;= 0 ? num1.charAt(i) - \u0026#39;0\u0026#39; : 0; int n2 = j \u0026gt;= 0 ? num2.charAt(j) - \u0026#39;0\u0026#39; : 0; int tmp = n1 + n2 + carry; carry = tmp / 10; res.append(tmp % 10); i--; j--; } if (carry == 1) res.append(1); return res.reverse().toString(); } } 合并k个升序链表hard https://leetcode.cn/problems/merge-k-sorted-lists/description/\n思路：分治\n把lists一分为二，先合并前一半的链表，再合并后一半的链表\n然后把这两个链表合并成最终的链表\n如何合并前一半的链表？可以用递归，继续一分为二。如此下去直到只有一个链表，此时无需合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public ListNode mergeKLists(ListNode[] lists) { return mergeKLists(lists, 0, lists.length); } // 合并从 lists[i] 到 lists[j-1] 的链表 private ListNode mergeKLists(ListNode[] lists, int i, int j) { int m = j - i; if (m == 0) { return null; // 注意输入的 lists 可能是空的 } if (m == 1) { return lists[i]; // 无需合并，直接返回 } ListNode left = mergeKLists(lists, i, i + m / 2); // 合并左半部分 ListNode right = mergeKLists(lists, i + m / 2, j); // 合并右半部分 return mergeTwoLists(left, right); // 最后把左半和右半合并 } // 21. 合并两个有序链表 private ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑 ListNode cur = dummy; // cur 指向新链表的末尾 while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { cur.next = list1; // 把 list1 加到新链表中 list1 = list1.next; } else { // 注：相等的情况加哪个节点都是可以的 cur.next = list2; // 把 list2 加到新链表中 list2 = list2.next; } cur = cur.next; } cur.next = list1 != null ? list1 : list2; // 拼接剩余链表 return dummy.next; } } Day3 排序数组（手撕快排） https://leetcode.cn/problems/sort-an-array/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); if (scanner.hasNext()) { int n = scanner.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = scanner.nextInt(); } quickSort(arr, 0, n - 1); StringBuilder sb = new StringBuilder(); for (int num : arr) { sb.append(num).append(\u0026#34; \u0026#34;); } System.out.println(sb.toString().trim()); // 去掉首尾空格 } scanner.close(); } private static void quickSort(int[] arr, int left, int right) { if (left \u0026lt; right) { int pivotIndex = partition(arr, left, right); quickSort(arr, left, pivotIndex - 1); quickSort(arr, pivotIndex + 1, right); } } private static int partition(int[] arr, int left, int right) { int pivot = arr[left]; int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; arr[j] \u0026gt;= pivot) j--; while (i \u0026lt; j \u0026amp;\u0026amp; arr[i] \u0026lt;= pivot) i++; if (i \u0026lt; j) { swap(arr, i, j); } } // 枢纽元素归位 swap(arr, left, i); return i; } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 最大子数组和 https://leetcode.cn/problems/maximum-subarray/description/\n思路：\n贪心的思想：\n对于每一个位置，决定是 “将当前的数加到之前的子数组中” 还是 “从当前的数重新开始一个新的子数组”\n如果以 x 前一个元素结尾的子数组和 pre 是正数（或者非负），那么加上 x 后，子数组变长了，和也变大了（或者没有变小），这对后续寻找最大和是有利的。所以，我们应该“继承”之前的成果\n如果 pre 是负数，说明之前的子数组是一个“累赘”。加上它只会让总和变小。既然是负数，不如直接扔掉，从 x 自己开始算，这就是“贪心”的体现——只要正收益，不要负累赘。\n1 2 3 4 5 6 7 8 9 10 class Solution { public int maxSubArray(int[] nums) { int pre = 0, maxAns = nums[0]; for (int x : nums) { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); } return maxAns; } } 最长回文子串 思路：动态规划\n1.状态定义：dp数组\ndp[l][r] 的含义是：字符串 s 从下标 l 到下标 r 的子串（即 s[l...r]）是否为回文串。\n2.状态转移方程：if (s.charAt(l) == s.charAt(r) \u0026amp;\u0026amp; (r - l \u0026lt;= 2 || dp[l + 1][r - 1]))\n一旦确认 s[l...r] 是回文（dp[l][r] = true），就检查它是否比当前记录的最长回文还长。如果是，就更新起止点和长度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String longestPalindrome(String s) { // 用一个 boolean dp[l][r] 标识字符串从i到j这段是否为回文。 // 如果dp[l][r] = true，要判断dp[l-1][r+1]是否为回文只需要判断l-1 r+1两个位置是否为相同字符 if (s == null || s.length() \u0026lt; 2) { return s; } int strLen = s.length(); int maxStart = 0; //最长回文的起点 int maxEnd = 0; // 最长回文的终点 int maxLen = 1; // 最长回文的长度 boolean[][] dp = new boolean[strLen][strLen]; for (int r = 1; r \u0026lt; strLen; r++) { for (int l = 0; l \u0026lt; r; l++) { if (s.charAt(l) == s.charAt(r) \u0026amp;\u0026amp; (r - l \u0026lt;= 2 || dp[l + 1][r - 1])) { // r - l \u0026lt;= 2是为了处理长度为2和3的短回文情况 dp[l][r] = true; if (r - l + 1 \u0026gt; maxLen) { maxLen = r - l + 1; maxStart = l; maxEnd = r; } } } } return s.substring(maxStart, maxEnd + 1); } } 合并两个有序链表 https://leetcode.cn/problems/merge-two-sorted-lists/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode cur = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } cur = cur.next; } cur.next = list1 != null ? list1 : list2; return dummy.next; } } 二叉树的层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\n思路：模板题\n使用队列\n遍历该节点时，判断该节点有无左右孩子，有的话加进队列中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { // 结果集合[[],[]] List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); // 使用队列维护 Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); if (root != null) { queue.add(root); } while (!queue.isEmpty()) { int n = queue.size(); List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } res.add(level); } return res; } } ","date":"2026-02-01T16:12:08+08:00","image":"https://Inorysekiro2333.github.io/p/leetcode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E5%B8%B8/119571089_hu_328e13177c767004.jpg","permalink":"https://Inorysekiro2333.github.io/p/leetcode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E5%B8%B8/","title":"【Leetcode】算法刷题日常"},{"content":" 克隆代码并部署 GitHub - KongVermouth/rag\n跟着README.MD文件到步骤4：启动Docker容器时卡住： 1 2 3 4 5 6 7 8 9 10 11 12 (rag) liuzhanhong@penglab3-Precision-7865-Tower:~/Code/RAG/rag/backend$ sudo docker-compose up -d [sudo] password for liuzhanhong: [+] Running 8/8 ✘ etcd Error 1.1s ✘ attu Error 1.1s ✘ minio Error 1.1s ✘ mysql8 Error 1.1s ✘ milvus-standalone Error 1.1s ✘ es Error 1.1s ✘ kibana Error 1.1s ✘ redis Error 1.1s Error response from daemon: Get \u0026#34;https://registry-1.docker.io/v2/\u0026#34;: read tcp [2001:da8:2019:e057:bab9:94a7:cee2:35a6]:56016-\u0026gt;[2600:1f18:2148:bc02:97a8:2125:f758:5652]:443: read: connection reset by peer 报错产生原因： 通过修改etc/docker/daemon.json换源和禁用ipv6都无法解决，询问大模型得知可能是校园网将Docker Hub给墙了。\n解决方式： 通过本地拉取所需的镜像，再一个个复制到服务器上（p.s.下面的代码需要一条一条执行）\n（1）拉取镜像：\n1 2 3 4 5 6 7 8 docker pull mysql:8.0 docker pull redis:7.2-alpine docker pull minio/minio:RELEASE.2023-12-23T07-19-11Z docker pull quay.io/coreos/etcd:v3.5.5 docker pull milvusdb/milvus:v2.4.10 docker pull elasticsearch:7.17.10 docker pull kibana:7.17.10 docker pull zilliz/attu:v2.4.12 （2）导出镜像：\n1 2 3 4 5 6 7 8 docker save mysql:8.0 -o mysql8.tar docker save redis:7.2-alpine -o redis7.tar docker save minio/minio:RELEASE.2023-12-23T07-19-11Z -o minio.tar docker save quay.io/coreos/etcd:v3.5.5 -o etcd.tar docker save milvusdb/milvus:v2.4.10 -o milvus.tar docker save elasticsearch:7.17.10 -o es.tar docker save kibana:7.17.10 -o kibana.tar docker save zilliz/attu:v2.4.12 -o attu.tarar （3）复制到penglab服务器：\n1 scp *.tar liuzhanhong@172.22.121.98:/home/liuzhanhong/docker-images/ （4）在服务器中一个一个加载：\n1 2 3 4 5 6 7 8 9 10 11 # 进到镜像目录 cd ~/docker-images # 加载镜像（每个命令单独执行） sudo docker load -i mysql8.tar sudo docker load -i redis7.tar ... # 重新执行docker-compose sudo docker-compose up -d （5）执行docker-compose发现es服务启动失败：原因是因为es的9200/9300端口被占用，修改docker-compose.yaml 文件，将es的端口改为19200/19300\n重新执行sudo docker-compose up -d成功启动所有服务\n建立数据库表 （1）使用DBeaver连接数据库，根据代码里的sql脚本创建table\n（2）sql脚本有几个地方需要修改的\n1 2 3 4 5 6 7 8 -- rag_knowledge 表 ALTER TABLE rag_knowledge CHANGE `document count` document_count INT DEFAULT 0; -- rag_robot 表 ALTER TABLE rag_robot CHANGE llm_id chat_llm_id BIGINT NOT NULL; ALTER TABLE rag_robot ADD COLUMN temperature FLOAT DEFAULT 0.7; ALTER TABLE rag_robot ADD COLUMN max_tokens INT DEFAULT 2000; ALTER TABLE rag_robot ADD COLUMN description VARCHAR(500); 因为后续在跑通流程的过程中发现前端传参和数据库表不一致，数据库缺失字段\nmodels/*.py实体类缺失 源码中没有提供models的所有实体类，需要自己根据数据库表自行创建\n模型文件全部改为SQLAIchemy ORM模型\nuser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026#34;\u0026#34;\u0026#34; User SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional from sqlalchemy import Column, Integer, String, DateTime, String from app.db.session import Base class User(Base): \u0026#34;\u0026#34;\u0026#34;用户模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_user\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;用户表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;用户ID\u0026#34;) username = Column(String(50), nullable=False, unique=True, comment=\u0026#34;用户名\u0026#34;) email = Column(String(100), nullable=False, unique=True, comment=\u0026#34;邮箱\u0026#34;) password_hash = Column(String(255), nullable=False, comment=\u0026#34;密码哈希\u0026#34;) password_changed_at = Column(DateTime, nullable=True, comment=\u0026#34;密码最后修改时间\u0026#34;) avatar_url = Column(String(255), nullable=True, comment=\u0026#34;头像地址\u0026#34;) role = Column(String(20), default=\u0026#34;user\u0026#34;, comment=\u0026#34;角色: admin, user\u0026#34;) status = Column(Integer, default=1, comment=\u0026#34;状态: 0=禁用, 1=正常\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;User(id={self.id}, username=\u0026#39;{self.username}\u0026#39;, email=\u0026#39;{self.email}\u0026#39;)\u0026gt;\u0026#34; def is_active(self) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;检查用户是否激活\u0026#34;\u0026#34;\u0026#34; return self.status == 1 def is_admin(self) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;检查是否为管理员\u0026#34;\u0026#34;\u0026#34; return self.role == \u0026#34;admin\u0026#34; llm.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026#34;\u0026#34;\u0026#34; LLM 大模型 SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional from sqlalchemy import Column, Integer, String, DateTime, Text from app.db.session import Base class LLM(Base): \u0026#34;\u0026#34;\u0026#34;大模型定义模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_llm\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;大模型定义表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;模型ID\u0026#34;) user_id = Column(Integer, nullable=False, comment=\u0026#34;创建者用户ID\u0026#34;) name = Column(String(100), nullable=False, comment=\u0026#34;模型显示名称\u0026#34;) provider = Column(String(50), nullable=False, comment=\u0026#34;提供商: openai, azure, anthropic, qwen\u0026#34;) model_name = Column(String(100), nullable=False, comment=\u0026#34;模型名称\u0026#34;) base_url = Column(String(255), nullable=True, comment=\u0026#34;API Endpoint\u0026#34;) api_version = Column(String(50), nullable=True, comment=\u0026#34;API版本\u0026#34;) model_type = Column(String(20), nullable=False, comment=\u0026#34;类型: chat, embedding, rerank\u0026#34;) max_tokens = Column(Integer, default=4096, comment=\u0026#34;最大上下文Token数\u0026#34;) description = Column(String(255), nullable=True, comment=\u0026#34;模型描述\u0026#34;) status = Column(Integer, default=1, comment=\u0026#34;状态：0-禁用，1-启用\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;LLM(id={self.id}, name=\u0026#39;{self.name}\u0026#39;, provider=\u0026#39;{self.provider}\u0026#39;)\u0026gt;\u0026#34; def is_chat_model(self) -\u0026gt; bool: return self.model_type == \u0026#34;chat\u0026#34; def is_embedding_model(self) -\u0026gt; bool: return self.model_type == \u0026#34;embedding\u0026#34; def is_rerank_model(self) -\u0026gt; bool: return self.model_type == \u0026#34;rerank\u0026#34; def is_active(self) -\u0026gt; bool: return self.status == 1 apikey.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026#34;\u0026#34;\u0026#34; APIKey SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional from sqlalchemy import Column, Integer, String, DateTime, Text from app.db.session import Base class APIKey(Base): \u0026#34;\u0026#34;\u0026#34;模型API Key管理模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_apikey\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;模型API Key管理表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;Key ID\u0026#34;) user_id = Column(Integer, nullable=False, comment=\u0026#34;创建者用户ID\u0026#34;) llm_id = Column(Integer, nullable=False, comment=\u0026#34;关联的模型ID\u0026#34;) api_key_encrypted = Column(Text, nullable=False, comment=\u0026#34;加密后的API Key\u0026#34;) alias = Column(String(100), nullable=False, comment=\u0026#34;Key别名\u0026#34;) description = Column(String(500), nullable=True, comment=\u0026#34;密钥描述\u0026#34;) status = Column(Integer, default=1, comment=\u0026#34;状态: 0=失效, 1=正常\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;APIKey(id={self.id}, alias=\u0026#39;{self.alias}\u0026#39;, llm_id={self.llm_id})\u0026gt;\u0026#34; def is_active(self) -\u0026gt; bool: return self.status == 1 knowledge.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026#34;\u0026#34;\u0026#34; Knowledge SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional from sqlalchemy import Column, Integer, String, DateTime, Text from app.db.session import Base class Knowledge(Base): \u0026#34;\u0026#34;\u0026#34;知识库模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_knowledge\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;知识库表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;知识库ID\u0026#34;) user_id = Column(Integer, nullable=False, comment=\u0026#34;所属用户ID\u0026#34;) name = Column(String(100), nullable=False, comment=\u0026#34;知识库名称\u0026#34;) description = Column(String(500), nullable=True, comment=\u0026#34;描述\u0026#34;) avatar = Column(String(255), nullable=True, comment=\u0026#34;知识库图标\u0026#34;) embed_llm_id = Column(Integer, nullable=False, comment=\u0026#34;使用的Embedding模型ID\u0026#34;) vector_collection_name = Column(String(100), nullable=False, comment=\u0026#34;向量数据库集合名称\u0026#34;) chunk_size = Column(Integer, default=500, comment=\u0026#34;切片大小\u0026#34;) chunk_overlap = Column(Integer, default=50, comment=\u0026#34;切片重叠大小\u0026#34;) document_count = Column(Integer, default=0, comment=\u0026#34;文档数量\u0026#34;) total_chunks = Column(Integer, default=0, comment=\u0026#34;总切片数\u0026#34;) status = Column(Integer, default=1, comment=\u0026#34;状态：0-禁用，1-启用\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;Knowledge(id={self.id}, name=\u0026#39;{self.name}\u0026#39;)\u0026gt;\u0026#34; def is_active(self) -\u0026gt; bool: return self.status == 1 document.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026#34;\u0026#34;\u0026#34; Document SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional, Dict, Any from sqlalchemy import Column, Integer, String, DateTime, BigInteger, Text, JSON from app.db.session import Base class Document(Base): \u0026#34;\u0026#34;\u0026#34;文档模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_document\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;文档表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;文档ID\u0026#34;) knowledge_id = Column(Integer, nullable=False, comment=\u0026#34;所属知识库ID\u0026#34;) file_name = Column(String(255), nullable=False, comment=\u0026#34;原始文件名\u0026#34;) file_path = Column(String(500), nullable=False, comment=\u0026#34;文件存储路径\u0026#34;) file_extension = Column(String(20), nullable=False, comment=\u0026#34;文件后缀\u0026#34;) file_size = Column(BigInteger, default=0, comment=\u0026#34;文件大小(字节)\u0026#34;) status = Column(String(20), default=\u0026#34;uploading\u0026#34;, comment=\u0026#34;状态: uploading, parsing, embedding, completed, failed\u0026#34;) chunk_count = Column(Integer, default=0, comment=\u0026#34;生成的切片数量\u0026#34;) error_msg = Column(Text, nullable=True, comment=\u0026#34;失败时的错误信息\u0026#34;) meta_data = Column(JSON, nullable=True, comment=\u0026#34;文档元数据\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;Document(id={self.id}, file_name=\u0026#39;{self.file_name}\u0026#39;)\u0026gt;\u0026#34; def is_completed(self) -\u0026gt; bool: return self.status == \u0026#34;completed\u0026#34; def is_failed(self) -\u0026gt; bool: return self.status == \u0026#34;failed\u0026#34; def get_file_size_mb(self) -\u0026gt; float: return round(self.file_size / (1024 * 1024), 2) robot.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026#34;\u0026#34;\u0026#34; Robot SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional, List, Dict, Any from sqlalchemy import Column, Integer, String, DateTime, Float, Text, JSON from app.db.session import Base class Robot(Base): \u0026#34;\u0026#34;\u0026#34;问答机器人模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_robot\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;问答机器人配置表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;机器人ID\u0026#34;) user_id = Column(Integer, nullable=False, comment=\u0026#34;所属用户ID\u0026#34;) name = Column(String(100), nullable=False, comment=\u0026#34;机器人名称\u0026#34;) avatar = Column(String(255), nullable=True, comment=\u0026#34;机器人头像\u0026#34;) chat_llm_id = Column(Integer, nullable=False, comment=\u0026#34;使用的对话模型ID\u0026#34;) system_prompt = Column(Text, nullable=True, comment=\u0026#34;系统提示词\u0026#34;) welcome_msg = Column(String(500), nullable=True, comment=\u0026#34;欢迎语\u0026#34;) suggested_questions = Column(JSON, nullable=True, comment=\u0026#34;推荐问题\u0026#34;) similarity_threshold = Column(Float, default=0.6, comment=\u0026#34;相似度阈值\u0026#34;) top_k = Column(Integer, default=5, comment=\u0026#34;召回切片数量\u0026#34;) temperature = Column(Float, default=0.7, comment=\u0026#34;生成温度\u0026#34;) max_tokens = Column(Integer, default=2000, comment=\u0026#34;最大生成Token数\u0026#34;) description = Column(String(500), nullable=True, comment=\u0026#34;机器人描述\u0026#34;) status = Column(Integer, default=1, comment=\u0026#34;状态: 0=下线, 1=上线\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;Robot(id={self.id}, name=\u0026#39;{self.name}\u0026#39;)\u0026gt;\u0026#34; def is_active(self) -\u0026gt; bool: return self.status == 1 robot_knowledge.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026#34;\u0026#34;\u0026#34; RobotKnowledge SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional from sqlalchemy import Column, Integer, DateTime from app.db.session import Base class RobotKnowledge(Base): \u0026#34;\u0026#34;\u0026#34;机器人-知识库关联模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_robot_knowledge\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;机器人知识库关联表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;ID\u0026#34;) robot_id = Column(Integer, nullable=False, comment=\u0026#34;机器人ID\u0026#34;) knowledge_id = Column(Integer, nullable=False, comment=\u0026#34;知识库ID\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;关联时间\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;RobotKnowledge(id={self.id}, robot_id={self.robot_id}, knowledge_id={self.knowledge_id})\u0026gt;\u0026#34; session.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026#34;\u0026#34;\u0026#34; Session SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional, Dict, Any from sqlalchemy import Column, Integer, String, DateTime, JSON from app.db.session import Base class Session(Base): \u0026#34;\u0026#34;\u0026#34;用户会话模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_session\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;用户会话表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;会话ID\u0026#34;) session_id = Column(String(64), nullable=False, unique=True, comment=\u0026#34;会话UUID\u0026#34;) user_id = Column(Integer, nullable=False, comment=\u0026#34;所属用户ID\u0026#34;) robot_id = Column(Integer, nullable=False, comment=\u0026#34;关联的机器人ID\u0026#34;) title = Column(String(200), nullable=True, comment=\u0026#34;会话标题\u0026#34;) summary = Column(String(500), nullable=True, comment=\u0026#34;会话摘要\u0026#34;) message_count = Column(Integer, default=0, comment=\u0026#34;消息数量\u0026#34;) status = Column(String(20), default=\u0026#34;active\u0026#34;, comment=\u0026#34;状态: active, archived, deleted\u0026#34;) is_pinned = Column(Integer, default=0, comment=\u0026#34;是否置顶: 0=否, 1=是\u0026#34;) last_message_at = Column(DateTime, nullable=True, comment=\u0026#34;最后一条消息时间\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, comment=\u0026#34;更新时间\u0026#34;) meta_data = Column(JSON, nullable=True, comment=\u0026#34;扩展元数据\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;Session(id={self.id}, session_id=\u0026#39;{self.session_id}\u0026#39;)\u0026gt;\u0026#34; def is_active(self) -\u0026gt; bool: return self.status == \u0026#34;active\u0026#34; def is_archived(self) -\u0026gt; bool: return self.status == \u0026#34;archived\u0026#34; def is_deleted(self) -\u0026gt; bool: return self.status == \u0026#34;deleted\u0026#34; # is_pinned既是列又是方法，名称冲突导致会话加载失败。 # def is_pinned(self) -\u0026gt; bool: # return self.is_pinned == 1 # 需要重命名方法 def get_is_pinned(self) -\u0026gt; bool: return self.is_pinned == 1 chat_history.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026#34;\u0026#34;\u0026#34; ChatHistory SQLAlchemy模型 \u0026#34;\u0026#34;\u0026#34; from datetime import datetime from typing import Optional, List, Dict, Any from sqlalchemy import Column, Integer, String, DateTime, Text, JSON from app.db.session import Base class ChatHistory(Base): \u0026#34;\u0026#34;\u0026#34;用户历史问答记录模型\u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#34;rag_chat_history\u0026#34; __table_args__ = {\u0026#34;comment\u0026#34;: \u0026#34;用户历史问答记录表\u0026#34;} id = Column(Integer, primary_key=True, autoincrement=True, comment=\u0026#34;记录ID\u0026#34;) session_id = Column(String(64), nullable=False, comment=\u0026#34;所属会话UUID\u0026#34;) message_id = Column(String(64), nullable=False, comment=\u0026#34;消息UUID\u0026#34;) role = Column(String(20), nullable=False, comment=\u0026#34;角色: user, assistant, system\u0026#34;) content = Column(Text, nullable=False, comment=\u0026#34;消息内容\u0026#34;) retrieved_contexts = Column(JSON, nullable=True, comment=\u0026#34;检索到的上下文\u0026#34;) referenced_doc_ids = Column(JSON, nullable=True, comment=\u0026#34;引用的文档ID列表\u0026#34;) prompt_tokens = Column(Integer, default=0, comment=\u0026#34;Prompt Token数\u0026#34;) completion_tokens = Column(Integer, default=0, comment=\u0026#34;回答 Token数\u0026#34;) total_tokens = Column(Integer, default=0, comment=\u0026#34;总Token数\u0026#34;) retrieval_time_ms = Column(Integer, default=0, comment=\u0026#34;检索耗时(毫秒)\u0026#34;) generation_time_ms = Column(Integer, default=0, comment=\u0026#34;生成耗时(毫秒)\u0026#34;) total_time_ms = Column(Integer, default=0, comment=\u0026#34;总耗时(毫秒)\u0026#34;) feedback = Column(Integer, nullable=True, comment=\u0026#34;用户反馈: 1=有用, -1=无用, NULL=未反馈\u0026#34;) feedback_comment = Column(String(500), nullable=True, comment=\u0026#34;反馈评论\u0026#34;) sequence = Column(Integer, nullable=False, comment=\u0026#34;消息序号\u0026#34;) created_at = Column(DateTime, default=datetime.now, comment=\u0026#34;创建时间\u0026#34;) meta_data = Column(JSON, nullable=True, comment=\u0026#34;扩展元数据\u0026#34;) def __repr__(self): return f\u0026#34;\u0026lt;ChatHistory(id={self.id}, role=\u0026#39;{self.role}\u0026#39;, sequence={self.sequence})\u0026gt;\u0026#34; def is_user_message(self) -\u0026gt; bool: return self.role == \u0026#34;user\u0026#34; def is_assistant_message(self) -\u0026gt; bool: return self.role == \u0026#34;assistant\u0026#34; def is_system_message(self) -\u0026gt; bool: return self.role == \u0026#34;system\u0026#34; def has_feedback(self) -\u0026gt; bool: return self.feedback is not None def is_useful(self) -\u0026gt; bool: return self.feedback == 1 def is_not_useful(self) -\u0026gt; bool: return self.feedback == -1 def get_total_time_seconds(self) -\u0026gt; float: return round(self.total_time_ms / 1000, 2) 运行下面命令启动后端和前端：\n1 2 3 4 python -m uvicorn app.main:app --reload --host 0.0.0.0 --port 8000 npm run dev 成功启动\n加载会话列表失败 session.py 中 is_pinned既是列又是方法，名称冲突。需要重命名方法：\n启动项目 注册用户\n配置LLM：对话模型+嵌入模型\n设置API密钥：对话模型\n新建知识库，上传文档\n添加机器人\n开始对话\n核心模块：从chat.py开始 ","date":"2026-01-15T12:57:15+08:00","image":"https://Inorysekiro2333.github.io/p/rag%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E7%BA%A7rag%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/PixPin_2026-01-17_20-13-22_hu_deeb785ab29cf075.jpg","permalink":"https://Inorysekiro2333.github.io/p/rag%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E7%BA%A7rag%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","title":"【RAG项目】企业级RAG项目实战"},{"content":"如何创建新的文章 进到dev目录，打开cmd终端，输入以下指令：\n1 hugo new content post/\u0026lt;新建文章的目录\u0026gt;/index.md 修改默认文章模板 在archetypes\\default.md中修改即可。\n","date":"2026-01-13T11:22:27+08:00","image":"https://Inorysekiro2333.github.io/p/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0hugo%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/PixPin_2026-01-17_20-16-24_hu_42f1ac38860d72a2.jpg","permalink":"https://Inorysekiro2333.github.io/p/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0hugo%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/","title":"【持续更新】HUGO操作手册"},{"content":"修改字体 （1）首先下载字体文件\n（2）把字体放在 assets/font下，自己创建文件夹\n（3）将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建)\n字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 添加最后更新时间 （1）在hugo.yaml中加入以下配置\n1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息 enableGitInfo: true （2）修改github action文件 .github/workflows/xxx.yaml， 在运行 hugo -D命令的step前加入以下配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 # 获取时间 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: Inorysekiro2333/Inorysekiro2333.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 新增友情链接、归档双栏显示 修改assets/scss/custom.scss 文件（不存在则自行创建）， 引入以下css样式代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 文章目录折叠\u0026amp;展开 将以下代码复制到layouts/partials/footer/custom.html文件中（不存在则自行创建）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; 返回顶部按钮 （1）准备一张返回顶部图片，放到assets/icons文件夹下\n（2）将以下代码复制到layouts/partials/footer/custom.html 文件中（不存在则自行创建）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/backTop.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; macOS风格的代码块 （1）准备一张macOS风格的红绿灯图，放到static/icons目录下\n（2）将以下代码复制到assets/scss/custom.scss文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; } .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(../icons/macOS-code-header.svg) no-repeat 0; background-size: contain; height: 18px; margin-top: -10px; margin-bottom: 10px; } 代码块过长的展开\u0026amp;折叠 （1）准备一张向下的箭头图，保存到assets/icons目录下\n（2）将以下代码复制到layouts/partials/footer/custom.html 文件中（不存在则自行创建）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; // 触发resize事件，重新计算目录位置 window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; 樱花动态特效 把樱花的动态特效js文件放到assets/background文件夹下，然后将以下代码复制到layouts/partials/footer/custom.html 文件中（不存在则自行创建）\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 无缝加载 引入PJAX https://github.com/MoOx/pjax\n根据文档，在layouts/partials/footer/custom.html中加入下面代码：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 问题修复 引入pjax以后会有以下问题：\n文章样式无法正常显示\n主题切换有问题\n文章搜索功能失效\n搜索内容跳转失效\nKaTeX失效\n下面一个个修复\n文章样式无法正常显示 layouts/partials/footer/custom.html中引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) } // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 主题切换修复 同样在footer/custom.html中引入\n1 2 3 4 5 6 \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 文章搜索和搜索功能跳转 （1）查看themes\\hugo-theme-stack\\assets\\ts\\search.tsx 注释掉window.addEventListener()函数，并在下面引入代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } （2）修改assets/ts/search.tsx代码，引入搜索初始化方法并调用\n1 2 3 4 5 6 7 8 9 ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } 在doSearch()方法末尾重新解析文档\n1 2 3 4 5 6 7 8 9 private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } （3）找到layouts/partials/footer/components/script.html补充下面内容\n\u0026ldquo;JSXFactory\u0026rdquo; \u0026ldquo;createElement\u0026rdquo;\n数学公式KaTex修复 （1）在layouts/partials/article/components/math.html添加元素\n1 \u0026lt;div class=\u0026#34;math-katex\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; （2）layouts/partials/footer/custom.html引入下面代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;script\u0026gt; async function renderKaTeX() { // 判断当前页面是否有KateX let katex = document.querySelector(\u0026#34;.math-katex\u0026#34;); if (!katex) { return; } // 等待函数加载成功后，再执行渲染方法 while (typeof renderMathInElement !== \u0026#39;function\u0026#39;) { await delay(500); } // KaTeX渲染方法 renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); } /** * 同步延迟 */ function delay(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time) }) } document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { renderKaTeX(); }) \u0026lt;/script\u0026gt; 虚拟进度条 （1）前往topbar by buunguyen\n解压后的topbar.min.js放到assets\\js\\topbar.min.js\n（2）footer\\custom.html引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; todolist 最底下的标签栏换掉✅\n文章的标题图片\n这里加上时间，字数统计等信息\n完善一下归档、标签\n动态背景✅\n鼠标指针\n音乐播放\nlive2D看板娘\n代码块美化 将代码块改为原生实现的 macOS 红绿灯风格，并添加悬停上浮效果。\n修改文件：assets/scss/custom.scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 代码块原生样式 - 简约现代风格 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; position: relative; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid var(--line-color); overflow: hidden; } .highlight:hover { transform: translateY(-6px); box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12) !important; } // 红绿灯头部 .highlight-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px; background: var(--code-background); border-bottom: 1px solid var(--line-color); } .highlight-dot { width: 12px; height: 12px; border-radius: 50%; transition: transform 0.2s ease; } .highlight-dot:nth-child(1) { background: #ff5f56; } .highlight-dot:nth-child(2) { background: #ffbd2e; } .highlight-dot:nth-child(3) { background: #27c93f; } // 悬停时红绿灯轻微放大 .highlight:hover .highlight-dot { transform: scale(1.1); } 修改文件：layouts/partials/footer/custom.html 添加红绿灯头部初始化脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- 代码块红绿灯头部 --\u0026gt; \u0026lt;script\u0026gt; function initCodeHeader() { const codeBlocks = document.querySelectorAll(\u0026#39;.highlight\u0026#39;); codeBlocks.forEach(block =\u0026gt; { if (block.querySelector(\u0026#39;.highlight-header\u0026#39;)) { return; } const header = document.createElement(\u0026#39;div\u0026#39;); header.className = \u0026#39;highlight-header\u0026#39;; const colors = [\u0026#39;#ff5f56\u0026#39;, \u0026#39;#ffbd2e\u0026#39;, \u0026#39;#27c93f\u0026#39;]; colors.forEach(color =\u0026gt; { const dot = document.createElement(\u0026#39;span\u0026#39;); dot.className = \u0026#39;highlight-dot\u0026#39;; dot.style.background = color; header.appendChild(dot); }); block.insertBefore(header, block.firstChild); }); } initCodeHeader(); \u0026lt;/script\u0026gt; 并在 pjax:complete 中添加 initCodeHeader() 调用。\n返回顶部按钮 右下角显示返回顶部按钮，滚动超过300px后显示。\n修改文件：layouts/partials/footer/custom.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;!-- 返回顶部按钮样式 --\u0026gt; \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; right: 24px; bottom: 24px; z-index: 100; cursor: pointer; width: 44px; height: 44px; background: var(--card-background); border: 1px solid var(--line-color); border-radius: 12px; box-shadow: var(--shadow-l1); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; } #backTopBtn:hover { background: var(--accent-color); border-color: var(--accent-color); transform: translateY(-2px); box-shadow: var(--shadow-l2); } #backTopBtn svg { width: 20px; height: 20px; color: var(--card-text-color); transition: color 0.3s ease; } #backTopBtn:hover svg { color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;!-- 返回顶部 --\u0026gt; \u0026lt;script\u0026gt; function initScrollTop() { if (document.getElementById(\u0026#39;backTopBtn\u0026#39;)) { document.getElementById(\u0026#39;backTopBtn\u0026#39;).remove(); } let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.innerHTML = `\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; fill=\u0026#34;none\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; stroke=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;path stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; stroke-width=\u0026#34;2\u0026#34; d=\u0026#34;M5 15l7-7 7 7\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt;`; btn.onclick = backToTop; document.body.appendChild(btn); window.addEventListener(\u0026#39;scroll\u0026#39;, function() { if (document.body.scrollTop \u0026gt; 300 || document.documentElement.scrollTop \u0026gt; 300) { btn.style.display = \u0026#39;flex\u0026#39;; } else { btn.style.display = \u0026#39;none\u0026#39;; } }); } function backToTop() { window.scrollTo({ top: 0, behavior: \u0026#39;smooth\u0026#39; }); } initScrollTop(); \u0026lt;/script\u0026gt; 特色图片悬浮效果 文章特色图片悬停时有轻微放大效果。\n修改文件：layouts/partials/article/components/header.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!-- 特色图片悬浮效果 --\u0026gt; \u0026lt;style\u0026gt; .article-image-wrapper { margin: -24px -24px 24px -24px; overflow: hidden; border-radius: var(--card-border-radius) var(--card-border-radius) 0 0; } .article-image { position: relative; overflow: hidden; } .featured-image { width: 100%; height: auto; max-height: 400px; object-fit: cover; transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1); } .article-image:hover .featured-image { transform: scale(1.03); } \u0026lt;/style\u0026gt; 字数统计 在文章底部显示字数统计。\n修改文件：layouts/partials/article/components/footer.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!-- 字数统计 --\u0026gt; \u0026lt;section class=\u0026#34;article-wordcount\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; fill=\u0026#34;none\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; stroke=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;path stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; stroke-width=\u0026#34;2\u0026#34; d=\u0026#34;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;span\u0026gt;{{ T \u0026#34;article.wordCount\u0026#34; .WordCount }}\u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 文章底部居中样式 --\u0026gt; \u0026lt;style\u0026gt; .article-footer { display: flex; flex-direction: column; align-items: center; gap: 16px; padding-top: 24px; margin-top: 32px; border-top: 1px solid var(--line-color); } .article-wordcount { display: flex; align-items: center; gap: 8px; color: var(--card-text-secondary); font-size: 13px; order: 0; } .article-wordcount svg { width: 16px; height: 16px; } \u0026lt;/style\u0026gt; 添加翻译：themes/hugo-theme-stack/i18n/zh-cn.yaml 1 2 wordCount: other: \u0026#34;字数: {{ .Count }}\u0026#34; 封面图片展示效果优化 ","date":"2026-01-11T21:44:13+08:00","image":"https://Inorysekiro2333.github.io/p/stack%E7%BE%8E%E5%8C%96%E4%B8%80%E4%BA%9B%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/1cc2da31-d479-4fb6-82a2-31dc69c2c7f0_hu_71ae5b6750d080bc.jpg","permalink":"https://Inorysekiro2333.github.io/p/stack%E7%BE%8E%E5%8C%96%E4%B8%80%E4%BA%9B%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/","title":"【Stack美化】一些样式修改"},{"content":"正文插入的图片无法正确显示 问题描述：在markdown文件中可以正确渲染的图片，但是在静态页面中无法正确渲染\n原因及解决方法：\n可能是图片保存路径错误，最好是图片与当前的markdown同级： 1 2 3 4 5 content/ └── post/ └── my-first-post/ \u0026lt;-- 文件夹名为文章 slug ├── index.md \u0026lt;-- 必须命名为 index.md └── cat.jpg \u0026lt;-- 图片文件 图片后缀最好为(*.jpg)，亲测使用png后缀导致渲染失败，可以设置截图工具以及markdown编辑器的图片保存路径和后缀：\n截图工具以pixpin为例，设置手动保存和自动保存的后缀均为.jpg： markdown编辑器以MarkText为例，设置图片保存路径为当前所在目录： ","date":"2026-01-11T19:30:59+08:00","image":"https://Inorysekiro2333.github.io/p/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E7%BB%B4%E6%8A%A4hugo%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/114677804_hu_b34081ec964ce118.jpg","permalink":"https://Inorysekiro2333.github.io/p/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E7%BB%B4%E6%8A%A4hugo%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"【持续更新】维护Hugo中遇到的问题"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n字体 返扇花週認契適違込遷雇述請曜藤突扉直角\n","date":"2020-09-09T00:00:00Z","image":"https://Inorysekiro2333.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_7d5f5b09f91c89db.jpg","permalink":"https://Inorysekiro2333.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Inorysekiro2333.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_9e6bcf9cfe9a9448.jpg","permalink":"https://Inorysekiro2333.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Inorysekiro2333.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_55222a4565f8ab23.jpg","permalink":"https://Inorysekiro2333.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Inorysekiro2333.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Inorysekiro2333.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_25e98f89e1c69204.jpg","permalink":"https://Inorysekiro2333.github.io/p/emoji-support/","title":"Emoji Support"}]